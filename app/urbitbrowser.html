<!DOCTYPE html>
<html>
<head>
  <title>Urbit Browser</title>
  <script src="https://unpkg.com/@urbit/http-api"></script>
  <script src="/session.js"></script>
  <link rel="stylesheet" type="text/css" href="/urbitbrowser/style.css"/>
</head>
<body>
  <header>
    <a id="title" href="#">UrbitBrowser</a>
    <div id="loginButtons">
      <button id="logOut" tyle="display:none;">Log out</button>
      <button id="arvoLoginButton" style="display:none;">Arvo Login</button>
      <button id="metaMaskLogInButton" style="display:none;">Azimuth Login</button>
      <div id="metaMaskSection">
        <input type="text" id="urbitId" placeholder="Enter Urbit ID"/>
        <button id="signInWithMetaMaskButton">Sign in</button>
      </div>
    </div>
  </header>
  
  <main>
  
    <div id="submitSection">
      <h2>Create post</h2>
      <input type="text" id="linkInput" placeholder="/~sampel-palnet/path" required="true">
      <div id="submitSectionTagPart">
        <div id="tagsInputContainer">
        <button type="button" id="addTags" onclick="addInput()" class="buttonPadding">Add Tags +</button>
        </div>
      </div>
      <textarea type="text" id="bodyInput" placeholder="Body"></textarea>
      <div id="submitButtonContainer">
        <div id="errorMessage">
        </div>
        <button id="submitButton">Submit</button>
      </div>
    </div>
  
    <p class="underlineText">Filters</p>
    <div id="filterContainer">
      <div id="sortFilter">
        <button id="selectTrigger" value="">Sort by:</button>
        <div id="selectArea">
          <div class="selectOption" value="top">Top</div>
          <div class="selectOption" value="new">New</div>
          <div class="selectOption" value="old">Old</div>
          <div class="selectOption" value="activity">Active</div>
        </div>
      </div>
      <input id="searchByPublished" type="text" placeholder="~sampel-palnet"/>
      <div id = "searchQueryContainer"></div>
      <button id="clearAll">Clear All</button>
    </div>
  
    <div id="emptyResult" style="display:none;">Nothing here</div>
    <div id="postsContainer"></div>
  </main>

  <script type="module">
  import ob from 'https://cdn.skypack.dev/urbit-ob';

    document.addEventListener("DOMContentLoaded", async function() {
      let posts = []
      localStorage.setItem('rank', JSON.stringify('commet'));
      let filter = "top"
      let searchPaths = []
      let searchTags = []
      let searchPostsState = []
      const api = new UrbitHttpApi.Urbit("");
      api.ship = window.ship;

      //subscribing for updates to urbitbrowser.hoon

      function pathSub() {
      window.id = api.subscribe({
        app: "urbitbrowser",
        path: "/paths",
        event: appendSubPost,
        quit: pathSub,
        err:()=>{console.log('Subscription fail')}
      });
      }

      //  GET req to set state

      try {
        const response = await fetch('/urbitbrowser/state');
        const data = await response.json();
        let challenge;

        const { paths, challenge: servChallenge, rank: userRank, patp} = data;
        localStorage.setItem('challenge', JSON.stringify(servChallenge));
        localStorage.setItem('rank', JSON.stringify(userRank));
        localStorage.setItem('urbitId', JSON.stringify(patp));
        challenge = servChallenge;

        if (userRank === "comet") {
          showCometLogin();
        } else {
          showSubmissionArea();
        }
        renderDropdown()
        pathSub()
        sortByPopular(paths, true)
      } catch (err) {
        console.error("Error fetching state:", err);
      }

      // setting html for comet 

      function showCometLogin() {
        document.getElementById("arvoLoginButton").style.display = "inline-block";
        document.getElementById("metaMaskLogInButton").style.display = "inline-block";

        document.getElementById("arvoLoginButton").addEventListener("click", function() {
          window.location.href = '/urbitbrowser/eauth';
        });

        document.getElementById("metaMaskLogInButton").addEventListener("click", function() {
          document.getElementById("metaMaskSection").style.display = "inline-block";
        });

        document.getElementById("signInWithMetaMaskButton").addEventListener("click", signInWithMetaMask);
      }

      //  Function that verifies whether the given path contains a valid patp

      function validPatp (path){
        const withoutFirstSlash = path.startsWith('/') ? path.slice(1) : path;
        const shipName = withoutFirstSlash.split('/')[0];
        console.log('ship name', shipName)
  
        const isValid = ob.isValidPatp(shipName)
        console.log('isValid?', isValid)

        return isValid
      }

      // setting html for authenticated user

      function showSubmissionArea() {
        let logOut = document.getElementById("logOut")
        logOut.style.display = "inline-block";


        const submitSection = document.getElementById("submitSection");
        submitSection.style.display = "flex";
        submitSection.style.flexDirection = "column"
        submitSection.style.gap = "5px"


        document.getElementById("submitButton").addEventListener("click", async () => {
          const linkValue = document.getElementById("linkInput").value.trim();
          const errElement = document.getElementById("errorMessage")
          const oldErrText = document.getElementById('errorText');

          const validPath = validPatp(linkValue)
          if (!linkValue) return;
          if (!validPath) {
            console.log('patp isnt valid')
            errElement.style.display = "flex";
            if (oldErrText) {
              oldErrText.remove();
            }
            const errText = createDiv('errorText')
            errText.innerHTML = "The provided @p in the path is invalid."
            errElement.appendChild(errText);
            return
          }

          const tags = document.querySelectorAll("#tagsInputContainer .newTag");

          const tagsArray = Array.from(tags).map(tag => tag.dataset.value.trim()).filter(value => value !== "");

          const bodyInput = document.getElementById("bodyInput");

          //  POST req to create a new post
          try {
            const resp = await fetch('/urbitbrowser', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ post: { path: linkValue, body: bodyInput.value, tags: tagsArray } })
            });
            console.log(resp)
            
            if(resp.status === 200){
              // clearing up form values
              console.log('old error text', oldErrText)
              if (oldErrText) {
              errElement.style.display = "none";
              oldErrText.remove();
            }

              document.getElementById('linkInput').value =''
              const tags = document.querySelectorAll('.tagsInput');
              tags.forEach(tag => {
                tag.remove();
              });
              bodyInput.value=''
            }else if (resp.status === 206) {
              //  handling err if path already been posted 

              const data = await resp.text();

              errElement.style.display = "flex";
              if (oldErrText) {
                oldErrText.remove();
              }
              const postLink = createDiv('postLink')
              postLink.innerHTML = `
              <a href="./urbitbrowser/post${linkValue}" style="color: red;">${data}</a>
              `
              errElement.appendChild(postLink)
            }else if (resp.status === 400 ) {
              const data = await resp.text();

              errElement.style.display = "flex";
              if (oldErrText) {
                oldErrText.remove();
              }
              const errText = createDiv('errorText')
              errText.innerHTML = data
              errElement.appendChild(errText);
            } else {
              console.error("Submission failed");
            }
          } catch (error) {
            console.error("Error submitting post:", error);
          }
        });
      }

      function appendSubPost(newPost){

        const arr = posts
        const index = arr.findIndex(obj => {
          return obj.path === newPost.path;
        });

        if (index !== -1) {
          posts[index] = newPost 

          if(searchPostsState.length != 0){
            let inputTag = document.getElementById("searchByTag")
            let inputPath = document.getElementById("searchByPublished")
            if(inputTag.value != '' & inputPath.value){
              newPost.tags.include(inputTag.value)
              newPost.path.startsWith(inputPath.value)
            }
            renderByFilter(searchPostsState)

          }else{
            renderByFilter(posts)
          }

        } else {
          console.log('adding new post', newPost)
          const errElement = document.getElementById("errorText")
          console.log('errElement', errElement)

          if(errElement){
            closeErrorMessage()
          }
          posts.push(newPost);
          renderPost(newPost)
        }
      }

      function renderPost(post){
  
        const container = document.getElementById("postsContainer");

        const { path, when, votes, score, submitter, tags, comments, link } = post;
  
        const postEl = createDiv('')
        postEl.className = "post";
        postEl.addEventListener('click', (event) => {
          window.location.href = `/urbitbrowser/post${path}`;
        })
  
        const voteSection = createDiv('')
        voteSection.className = "voteSection";
  
        const upArrow = createDiv('')
        upArrow.className = "voteArrow";
        upArrow.textContent = "+";
        upArrow.addEventListener("click", (event) => {
          event.stopPropagation()
          voteOnPath(path, true)
        });
  
        const scoreEl = createDiv('')
        scoreEl.textContent = score;
        const downArrow = createDiv('')
        downArrow.className = "voteArrow";
        downArrow.textContent = "-";
        downArrow.addEventListener("click", (event) => {
          event.stopPropagation()
          voteOnPath(path, false)
        });
      
        if(votes){
          const isVoted = votes.find(element => element.ship === UrbitId());
          if(isVoted && isVoted.vote === true){
            upArrow.style.fontWeight = 'bold';
          }
          if(isVoted && isVoted.vote === false){
            downArrow.style.fontWeight = 'bold';
          }
        }

        voteSection.appendChild(upArrow);
        voteSection.appendChild(scoreEl);
        voteSection.appendChild(downArrow);
  
        const postContent = createDiv('')
        postContent.className = "postContent";
        const postTitle = document.createElement("a");
  
        postTitle.className = "postTitle";
        postTitle.textContent = path;
        postTitle.href = link || "#";
        postTitle.target = "_blank";
        postTitle.addEventListener("click", (event) =>
        event.stopPropagation()
      )
  
        const timestamp = new Date(when).toLocaleString();
        const postInfo = createDiv('')
  
        postInfo.className = "postInfo";
        const postText = createDiv()
        postText.innerHTML = `Submitted by ${submitter} <span class="separator">|</span> ${comments.length} Comments <span class="separator">|</span> ${timestamp}`;
  
        const tagsContainer = createDiv('')
        tagsContainer.className = "tagsContainer"
        tags.forEach(tag => {
          const tagElement = document.createElement('button');
          tagElement.className = "tag"
          tagElement.innerHTML = tag
          tagElement.addEventListener("click", (event) => {
            event.stopPropagation()
            let inputTag = document.getElementById("searchByTag")
            inputTag.value=tag
            let inputEvent = new Event('input', {
              bubbles: true,
              cancelable: true
            });
            inputTag.dispatchEvent(inputEvent);
          })

          const separator = document.createElement('span')
          separator.className = 'separator'
          separator.innerText = '|'
          tagsContainer.appendChild(separator)
          tagsContainer.appendChild(tagElement)
        })
        postInfo.appendChild(postText)
        postInfo.appendChild(tagsContainer);
        
        postContent.appendChild(postTitle);
        postContent.appendChild(postInfo);
  
        postEl.appendChild(voteSection);
        postEl.appendChild(postContent);
        container.insertBefore(postEl, container.firstChild);
      }

      function renderPosts(paths, isFetched) {
        const container = document.getElementById("postsContainer");
        container.innerHTML = "";
        const emptyResult = document.getElementById("emptyResult")

        if(paths.length === 0){
          emptyResult.style.display = "block"
        }else{
          emptyResult.style.display = "none"
          if(isFetched){
            console.log('just fetched data')
            paths.forEach(post => {
              posts.push(post);
              renderPost(post)
            })
          }else{
            paths.forEach(post => {
              renderPost(post)
            })
          }
        }
      }

      //  POST vote req

      async function voteOnPath(path, isUpvote) {
        if (Rank() === "comet") {
          //  TODO: add login pop up
          alert("You must log in to vote.");
          return;
        }
        try {
          console.log(path)
          const resp = await fetch('/urbitbrowser', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ vote: { path: path, vote: isUpvote } })
          });
          if (resp.ok) {
            console.log('voted')
          } else {
            console.error('vote failed')
          }
        } catch (err) {
          console.error("Error sending vote:", err);
        }
      }

      async function signInWithMetaMask() {
        try {
          const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
          const account = accounts[0];
          const signature = await window.ethereum.request({
            method: "personal_sign",
            params: [account, Challenge()],
          });
          const body = {
            who: document.getElementById("urbitId").value,
            address: account,
            signature: signature,
            secret: Challenge(),
          };
          const response = await fetch('/urbitbrowser', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ auth: body }),
          });
          if (response.ok) {
            location.reload();
          } else {
            alert("Login failed. Please try again.");
          }
        } catch (error) {
          console.error("MetaMask login failed:", error);
          alert("An error occurred during MetaMask login. Please try again.");
        }
      }

      //  Custom filter dropdown logic

      function renderDropdown() {
        const select = document.getElementById('sortFilter');
        const trigger = document.getElementById('selectTrigger');
        const options = document.getElementById('selectArea');
        const optionItems = select.querySelectorAll('.selectOption');

        trigger.addEventListener('click', (event) => {
          event.stopPropagation()
          options.classList.toggle('open');
        });
  
        optionItems.forEach(option => {
          option.addEventListener('click', (event) => {
            trigger.textContent = option.textContent;

            filter = option.getAttribute('value')
            renderByFilter (searchPostsState.length === 0 ? posts : searchPostsState)

            options.classList.remove('open');
            event.stopPropagation();
          });
        });

        document.addEventListener('click', (event) => {
          if (options.classList.contains('open')) {
            options.classList.remove('open');
          }
        })
      }

      function renderByFilter(postsArr){
        if(filter === 'top'){
          console.log('sorting by popular', postsArr)
          // sort array by votes 
          sortByPopular(postsArr, false)
        }else if(filter ==='new'){
          const sortedPosts = [...postsArr].sort((a, b) => a.when - b.when);
          renderPosts(sortedPosts, false)
        }else if(filter ==='old'){
          const sortedPosts = [...postsArr].sort((a, b) => b.when - a.when);
          renderPosts(sortedPosts, false)
        }else if(filter = 'activity'){
          const sortedPosts = postsArr.sort((a, b) => {
            const latestCommentA = a.comments.length > 0 ? Math.max(...a.comments.map(comment => comment.when)) : -Infinity;
            const latestCommentB = b.comments.length > 0 ? Math.max(...b.comments.map(comment => comment.when)) : -Infinity;
            console.log(latestCommentB - latestCommentA)
            return latestCommentA - latestCommentB;
           });
          console.log('sorted', sortedPosts)
          renderPosts(sortedPosts, false)
        }
      }

      //  isFetched - stands for initial fetch of state/first rendering
      function sortByPopular(postsArr, isFetched){
        const sortedPosts = [...postsArr].sort((a, b) => a.score - b.score);
        renderPosts(sortedPosts, isFetched)
      }

      document.getElementById("searchByPublished").addEventListener("keydown", async () => {
        if (event.key === "Enter") {
          let container = document.getElementById("searchQueryContainer")
          let input = document.getElementById("searchByPublished")
          let inputValue = input.value;
          input.value = ''
          document.getElementById('clearAll').classList.add('open');

          //  add new search element to div 
          let searchElem = createDiv('')
          let XButton = document.createElement('button');
          XButton.innerText = "x"
          XButton.addEventListener("click", () => {
            searchElem.remove();
            searchPaths = searchPaths.filter(item => item !== inputValue);
            searchTags = searchTags.filter(item => item !== inputValue);
            //  TODO:  rerenderPosts
          })

          if (inputValue.startsWith('/~') || inputValue.startsWith('~')) {
            console.log('search by path')
            if(inputValue.startsWith('~')){
              searchElem.innerHTML = `<div>/${inputValue}</div>`
              inputValue = '/' + inputValue
            }else{
              searchElem.innerHTML = `<div>${inputValue}</div>`
            }
            if (searchPaths.includes(inputValue)) return;
            //  value is a path 
            if(searchPaths.length == 0 && searchTags.length == 0){
              //  if filter by path and tag are empty 
              //  render through main posts array
              console.log('if filter by path and tag are empty')
              const filteredPosts = getPostBySearch(posts, inputValue)
              searchPostsState = filteredPosts
              renderByFilter(filteredPosts)
            }else{
              //  if has tags search through searchPostsState
              if(searchTags.length != 0 && searchPaths.length == 0){
                console.log('has tags search through searchPostsState')
                const filteredPosts = getPostBySearch(searchPostsState, inputValue)
                searchPostsState = filteredPosts
                renderByFilter(filteredPosts)
              }else if(searchPaths.length != 0){
                const filteredPosts = getPostBySearch(posts, inputValue)
                console.log('filtered posts', filteredPosts)
                let postsArr = filteredPosts
                if(searchTags.length != 0){
                  searchTags.forEach(tag => {
                    postsArr = filterByTag(postsArr, tag);
                  });
                }
                let mergedPosts = [...new Set([...searchPostsState, ...postsArr])];
                renderByFilter(mergedPosts)
              }
            }
            //  add to array of filteredByPath 
            searchPaths.push(inputValue)
            //  else render through filtered array
          }else{
            if(inputValue.startsWith('#')){
              searchElem.innerHTML = `<div>${inputValue}</div>`
              inputValue = inputValue.slice(1)
              console.log('inputValue', inputValue)
            }else{
              searchElem.innerHTML = `<div>#${inputValue}</div>`
            }
            if(searchTags.includes(inputValue)) return;
            console.log('search by tag')
            console.log(searchPaths)
            console.log(searchTags)
            //  value is a tag
            if(searchPaths.length != 0 || searchTags.length != 0){
              console.log('through searchPostsState')
              renderPostsByTag(searchPostsState, inputValue)
            }else{
              console.log('through all posts')
              renderPostsByTag(posts, inputValue)
            }
            //  add to array of filteredByTag
            searchTags.push(inputValue)
          }
          searchElem.appendChild(XButton)
          container.append(searchElem)
        }
      })

      document.getElementById('clearAll').addEventListener("click", () => {
        let searchPaths = []
        let searchTags = []
        let searchPostsState = []
        renderByFilter(posts)
        document.getElementById('searchQueryContainer').innerHTML = ''
        document.getElementById('clearAll').classList.remove('open');
      })
      
      function getPostBySearch(postsArr, query){
        const filteredPosts = postsArr.filter(post => post.path.startsWith(query));
        console.log(query, filteredPosts)
        // Sort the array based on the '/' values (after '/')
        const sortedPosts = filteredPosts.sort((a, b) => {
          // Extract the part after the '/' to compare
          const aValue = a.path.startsWith('/') ? a.path.slice(1) : a;
          const bValue = b.path.startsWith('/') ? b.path.slice(1) : b;
          return aValue.localeCompare(bValue);  // Sort alphabetically
        })
      return sortedPosts
      }

      function renderPostsByTag(postsArr, tag){
        const filteredPosts = filterByTag(postsArr, tag)
        searchPostsState = filteredPosts
        renderByFilter(filteredPosts)
      }
    })

    function filterByTag(postsArr, tag){
      return postsArr.filter(post => post.tags.includes(tag));
    }

    function Challenge(){
      return JSON.parse(localStorage.getItem('challenge'))
    }
    function UrbitId(){
      return JSON.parse(localStorage.getItem('urbitId'))
    }
    function Rank(){
      return JSON.parse(localStorage.getItem('rank'))
    }
    function createDiv(idValue){
      const div = document.createElement('div');
      div.id = idValue
      return div
    }

  </script>
  <script>
    function closeErrorMessage(){
      const errElement = document.getElementById("errorMessage")
      errElement.style.display = "none";
      const errText = document.getElementById("errorText")
      errElement.removeChild(errText)
    }

    function addInput() {
      let button = document.getElementById('addTags');
      button.style.display = "none"
      let container = document.getElementById('tagsInputContainer');
      container.style.display = "flex"
      container.style.gap = "5px"
      container.style.flexWrap = "wrap"
      let input = document.createElement('input');
      input.type = "text"
      input.id = "tagsInput"
      input.placeholder = "#tag"
      container.insertBefore(input, container.firstChild);
      input.focus();
      input.addEventListener("keydown", () => {
        if (event.key === "Enter") {
          console.log('assign value:', input.value)
          button.style.display = "block"
          let tag = document.createElement('div');
          tag.className = "newTag"
          tag.dataset.value = input.value
          let tagText = document.createElement('div');
          tagText.innerText = input.value
          let XButton = document.createElement('button');
          XButton.innerText = "x"
          XButton.addEventListener("click", ()=>{
            tag.remove();
          })
          tag.appendChild(tagText)
          tag.appendChild(XButton)

          input.style.display = "none"
          input.value = ''

          container.appendChild(tag)
        }
      })
    }
  </script>
</body>
</html>