<!DOCTYPE html>
<html>
<head>
  <title>Urbit Browser</title>
  <script src="https://unpkg.com/@urbit/http-api"></script>
  <script src="/session.js"></script>
  <link rel="stylesheet" type="text/css" href="/urbitbrowser/style.css"/>
</head>
<body>
  <header>
    <a id="title" href="#">UrbitBrowser</a>
    <div id="loginButtons">
      <button id="arvoLoginButton" style="display:none;">Arvo Login</button>
      <button id="metaMaskLogInButton" style="display:none;">Azimuth Login</button>
      <div id="metaMaskSection">
        <input type="text" id="urbitId" placeholder="Enter Urbit ID"/>
        <button id="signInWithMetaMaskButton">Sign in</button>
      </div>
    </div>
  </header>
  
  <main>
  
    <div id="submitSection">
      <h2>Create post</h2>
      <input type="text" id="linkInput" placeholder="/~sampel-palnet/path" required="true">
      <div id="submitSectionTagPart">
        <button type="button" onclick="addInput()" class="buttonPadding">Add Tags +</button>
        <div id="tagsInputContainer" style="display:none;">
        </div>
      </div>
      <textarea type="text" id="bodyInput" placeholder="Body"></textarea>
      <div id="submitButtonContainer">
        <div id="errorMessage">
        </div>
        <button id="submitButton">Submit</button>
      </div>
    </div>
  
    <p class="underlineText">Filters</p>
    <div id="filterContainer">
      <select id="sortFilter">
        <option value="" disabled selected>Sort by:</option>
        <option value="top">Top</option>
        <option value="new">New</option>
        <option value="old">Old</option>
        <option value="activity">Activity</option>
      </select>
      <input id="searchByPublished" type="text" placeholder="~sampel-palnet"/>
      <input id="searchByTag" type="text" placeholder="#urbit"/>
    </div>
  
    <div id="emptyResult" style="display:none;">Nothing here</div>
    <div id="postsContainer"></div>
  </main>

  <script type="module">
  import ob from 'https://cdn.skypack.dev/urbit-ob';

    document.addEventListener("DOMContentLoaded", async function() {
      let posts = []
      localStorage.setItem('rank', JSON.stringify('commet'));
      let filter = "top"
      let searchPostsState = []
      const api = new UrbitHttpApi.Urbit("");
      api.ship = window.ship;

      //subscribing for updates to urbitbrowser.hoon

      function pathSub() {
      window.id = api.subscribe({
        app: "urbitbrowser",
        path: "/paths",
        event: appendSubPost,
        quit: pathSub,
        err:()=>{console.log('Subscription fail')}
      });
      }

      //  GET req to set state

      try {
        const response = await fetch('/urbitbrowser/state');
        const data = await response.json();
        let challenge;

        const { paths, challenge: servChallenge, rank: userRank, patp} = data;
        localStorage.setItem('challenge', JSON.stringify(servChallenge));
        localStorage.setItem('rank', JSON.stringify(userRank));
        localStorage.setItem('urbitId', JSON.stringify(patp));
        challenge = servChallenge;

        if (userRank === "comet") {
          showCometLogin();
        } else {
          showSubmissionArea();
        }
        pathSub()
        sortByPopular(paths, true)
      } catch (err) {
        console.error("Error fetching state:", err);
      }

      // setting html for comet 

      function showCometLogin() {
        document.getElementById("arvoLoginButton").style.display = "inline-block";
        document.getElementById("metaMaskLogInButton").style.display = "inline-block";

        document.getElementById("arvoLoginButton").addEventListener("click", function() {
          window.location.href = '/urbitbrowser/eauth';
        });

        document.getElementById("metaMaskLogInButton").addEventListener("click", function() {
          document.getElementById("metaMaskSection").style.display = "inline-block";
        });

        document.getElementById("signInWithMetaMaskButton").addEventListener("click", signInWithMetaMask);
      }

      //  Function that verifies whether the given path contains a valid patp

      function validPatp (path){
        const withoutFirstSlash = path.startsWith('/') ? path.slice(1) : path;
        const shipName = withoutFirstSlash.split('/')[0];
        console.log('ship name', shipName)
  
        const isValid = ob.isValidPatp(shipName)
        console.log('isValid?', isValid)

        return isValid
      }

      // setting html for authenticated user

      function showSubmissionArea() {
        const submitSection = document.getElementById("submitSection");
        submitSection.style.display = "flex";
        submitSection.style.flexDirection = "column"
        submitSection.style.gap = "5px"


        document.getElementById("submitButton").addEventListener("click", async () => {
          const linkValue = document.getElementById("linkInput").value.trim();
          const errElement = document.getElementById("errorMessage")
          const oldErrText = document.getElementById('errorText');

          const validPath = validPatp(linkValue)
          if (!linkValue) return;
          if (!validPath) {
            console.log('patp isnt valid')
            errElement.style.display = "flex";
            if (oldErrText) {
              oldErrText.remove();
            }
            const errText = createDiv('errorText')
            errText.innerHTML = "The provided @p in the path is invalid."
            errElement.appendChild(errText);
            return
          }

          const tagsInputs = document.querySelectorAll("#tagsInputContainer .tagsInput");

          console.log('tagsInputs', tagsInputs)

          const tagsArray = Array.from(tagsInputs).map(input => input.value.trim()).filter(value => value !== "");

          const bodyInput = document.getElementById("bodyInput");

          //  POST req to create a new post
          try {
            const resp = await fetch('/urbitbrowser', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ post: { path: linkValue, body: bodyInput.value, tags: tagsArray } })
            });
            console.log(resp)
            
            if(resp.status === 200){
              // clearing up form values
              console.log('old error text', oldErrText)
              if (oldErrText) {
              errElement.style.display = "none";
              oldErrText.remove();
            }

              document.getElementById('linkInput').value =''
              const tags = document.querySelectorAll('.tagsInput');
              tags.forEach(tag => {
                tag.remove();
              });
              bodyInput.value=''
            }else if (resp.status === 206) {
              //  handling err if path already been posted 

              const data = await resp.text();

              errElement.style.display = "flex";
              if (oldErrText) {
                oldErrText.remove();
              }
              const postLink = createDiv('postLink')
              postLink.innerHTML = `
              <a href="./urbitbrowser/post${linkValue}" style="color: red;">${data}</a>
              `
              errElement.appendChild(postLink)
            }else if (resp.status === 400 ) {
              const data = await resp.text();

              errElement.style.display = "flex";
              if (oldErrText) {
                oldErrText.remove();
              }
              const errText = createDiv('errorText')
              errText.innerHTML = data
              errElement.appendChild(errText);
            } else {
              console.error("Submission failed");
            }
          } catch (error) {
            console.error("Error submitting post:", error);
          }
        });
      }

      function appendSubPost(newPost){

        const arr = posts
        const index = arr.findIndex(obj => {
          return obj.path === newPost.path;
        });

        if (index !== -1) {
          posts[index] = newPost 

          if(searchPostsState.length != 0){
            let inputTag = document.getElementById("searchByTag")
            let inputPath = document.getElementById("searchByPublished")
            if(inputTag.value != '' & inputPath.value){
              newPost.tags.include(inputTag.value)
              newPost.path.startsWith(inputPath.value)

            }
            renderByFilter(searchPostsState)
          }else{
            renderByFilter(posts)
          }
        } else {
          console.log('adding new post', newPost)
          const errElement = document.getElementById("errorText")
          console.log('errElement', errElement)
          if(errElement){
            closeErrorMessage()
          }
          posts.push(newPost);
          renderPost(newPost)
        }
      }

      function renderPost(post){
  
        const container = document.getElementById("postsContainer");

        const { path, when, votes, score, submitter, tags, comments, link } = post;
  
        const postEl = createDiv('')
        postEl.className = "post";
        postEl.addEventListener('click', (event) => {
          window.location.href = `/urbitbrowser/post${path}`;
        })
  
        const voteSection = createDiv('')
        voteSection.className = "voteSection";
  
        const upArrow = createDiv('')
        upArrow.className = "voteArrow";
        upArrow.textContent = "+";
        upArrow.addEventListener("click", (event) => {
          event.stopPropagation()
          voteOnPath(path, true)
        });
  
        const scoreEl = createDiv('')
        scoreEl.textContent = score;
        const downArrow = createDiv('')
        downArrow.className = "voteArrow";
        downArrow.textContent = "-";
        downArrow.addEventListener("click", (event) => {
          event.stopPropagation()
          voteOnPath(path, false)
        });
      
        if(votes){
          const isVoted = votes.find(element => element.ship === UrbitId());
          if(isVoted && isVoted.vote === true){
            upArrow.style.fontWeight = 'bold';
          }
          if(isVoted && isVoted.vote === false){
            downArrow.style.fontWeight = 'bold';
          }
        }

        voteSection.appendChild(upArrow);
        voteSection.appendChild(scoreEl);
        voteSection.appendChild(downArrow);
  
        const postContent = createDiv('')
        postContent.className = "postContent";
        const postTitle = document.createElement("a");
  
        postTitle.className = "postTitle";
        postTitle.textContent = path;
        postTitle.href = link || "#";
        postTitle.target = "_blank";
        postTitle.addEventListener("click", (event) =>
        event.stopPropagation()
      )
  
        const timestamp = new Date(when).toLocaleString();
        const postInfo = createDiv('')
  
        postInfo.className = "postInfo";
        const postText = createDiv()
        postText.innerHTML = `Submitted by ${submitter} <span class="separator">|</span> ${comments.length} Comments <span class="separator">|</span> ${timestamp}`;
  
        const tagsContainer = createDiv('')
        tagsContainer.className = "tagsContainer"
        tags.forEach(tag => {
          const tagElement = document.createElement('button');
          tagElement.className = "tag"
          tagElement.innerHTML = tag
          tagElement.addEventListener("click", (event) => {
            event.stopPropagation()
            let inputTag = document.getElementById("searchByTag")
            inputTag.value=tag
            let inputEvent = new Event('input', {
               bubbles: true,
               cancelable: true
             });
             inputTag.dispatchEvent(inputEvent);
          })

          const separator = document.createElement('span')
          separator.className = 'separator'
          separator.innerText = '|'
          tagsContainer.appendChild(separator)
          tagsContainer.appendChild(tagElement)
        })
        postInfo.appendChild(postText)
        postInfo.appendChild(tagsContainer);
        
        postContent.appendChild(postTitle);
        postContent.appendChild(postInfo);
  
        postEl.appendChild(voteSection);
        postEl.appendChild(postContent);
        container.insertBefore(postEl, container.firstChild);
      }

      function renderPosts(paths, isFetched) {
        const container = document.getElementById("postsContainer");
        container.innerHTML = "";
        const emptyResult = document.getElementById("emptyResult")

        if(paths.length === 0){
          emptyResult.style.display = "block"
        }else{
          emptyResult.style.display = "none"
          if(isFetched){
            console.log('just fetched data')
            paths.forEach(post => {
              posts.push(post);
              renderPost(post)
            })
          }else{
            paths.forEach(post => {
              renderPost(post)
            })
          }
        }
      }

      //  POST vote req

      async function voteOnPath(path, isUpvote) {
        if (Rank() === "comet") {
          //  TODO: add login pop up
          alert("You must log in to vote.");
          return;
        }
        try {
          console.log(path)
          const resp = await fetch('/urbitbrowser', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ vote: { path: path, vote: isUpvote } })
          });
          if (resp.ok) {
            console.log('voted')
          } else {
            console.error('vote failed')
          }
        } catch (err) {
          console.error("Error sending vote:", err);
        }
      }

      async function signInWithMetaMask() {
        try {
          const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
          const account = accounts[0];
          const signature = await window.ethereum.request({
            method: "personal_sign",
            params: [account, Challenge()],
          });
          const body = {
            who: document.getElementById("urbitId").value,
            address: account,
            signature: signature,
            secret: Challenge(),
          };
          const response = await fetch('/urbitbrowser', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ auth: body }),
          });
          if (response.ok) {
            location.reload();
          } else {
            alert("Login failed. Please try again.");
          }
        } catch (error) {
          console.error("MetaMask login failed:", error);
          alert("An error occurred during MetaMask login. Please try again.");
        }
      }

      //  sorting functionlaity 

      document.getElementById("sortFilter").addEventListener("change", async () => {
        const param = event.target.value;
        filter = param
        console.log(searchPostsState.length, searchPostsState)
        console.log(searchPostsState.length === 0 ? 'posts' : 'searchPostsState')
        renderByFilter (searchPostsState.length === 0 ? posts : searchPostsState)
      })

      function renderByFilter(postsArr){
        if(filter === 'top'){
          console.log('sorting by popular', postsArr)
          // sort array by votes 
          sortByPopular(postsArr, false)
        }else if(filter ==='new'){
          const sortedPosts = [...postsArr].sort((a, b) => a.when - b.when);
          renderPosts(sortedPosts, false)
        }else if(filter ==='old'){
          const sortedPosts = [...postsArr].sort((a, b) => b.when - a.when);
          renderPosts(sortedPosts, false)
        }else if(filter = 'activity'){
          const sortedPosts = postsArr.sort((a, b) => {
            const latestCommentA = a.comments.length > 0 ? Math.max(...a.comments.map(comment => comment.when)) : -Infinity;
            const latestCommentB = b.comments.length > 0 ? Math.max(...b.comments.map(comment => comment.when)) : -Infinity;
            console.log(latestCommentB - latestCommentA)
            return latestCommentA - latestCommentB;
           });
          console.log('sorted', sortedPosts)
          renderPosts(sortedPosts, false)
        }
      }

      //  isFetched - stands for initial fetch of state/first rendering
      function sortByPopular(postsArr, isFetched){
        const sortedPosts = [...postsArr].sort((a, b) => a.score - b.score);
        renderPosts(sortedPosts, isFetched)
      }

      document.getElementById("searchByPublished").addEventListener("input", async () => {
        let input = document.getElementById("searchByPublished")
        let inputTag = document.getElementById("searchByTag")
        let inputValue = input.value;

        if(inputValue === ''){
          if(inputTag.value === ''){
            searchPostsState = []
            renderByFilter(posts)
          }else{
            renderPostsByTag(posts, inputTag.value)
          }
        }else{
          if(inputTag.value === ''){
            const filteredPosts = renderPostBySearch(inputValue)
            searchPostsState = filteredPosts
            renderByFilter(filteredPosts)
          }else{
            const filteredPosts = renderPostBySearch(inputValue)
            renderPostsByTag(filteredPosts, inputTag.value)
          }
        }
      })

      document.getElementById("searchByTag").addEventListener("input", async () => {
        let inputTag = document.getElementById("searchByTag")
        let inputPath = document.getElementById("searchByPublished")
        if(inputTag.value === ''){
          if(inputPath.value === ''){
            console.log('no filter')
            searchPostsState = []
            renderByFilter(posts)
          }else{
            console.log('no tag filter')
            const filteredPosts = renderPostBySearch(inputPath.value)
            searchPostsState = filteredPosts
            console.log(filteredPosts)
            renderByFilter(filteredPosts)
          }
        }else{
          if(inputPath.value === ''){
            renderPostsByTag(posts, inputTag.value)
          }else{
            console.log('double filter through tags', posts)
            const filteredPosts = renderPostBySearch(inputPath.value)
            console.log(filteredPosts, inputPath.value)
            renderPostsByTag(filteredPosts, inputTag.value)
          }
        }
      })
      
      function renderPostBySearch(query){
        if (!query.startsWith('/')) {
          query = '/' + query;
        }

        const filteredPosts = posts.filter(post => post.path.startsWith(query));
        console.log(query, filteredPosts)
        // Sort the array based on the '/' values (after '/')
        const sortedPosts = filteredPosts.sort((a, b) => {
          // Extract the part after the '/' to compare
          const aValue = a.path.startsWith('/') ? a.path.slice(1) : a;
          const bValue = b.path.startsWith('/') ? b.path.slice(1) : b;
          return aValue.localeCompare(bValue);  // Sort alphabetically
        })
      return sortedPosts

      }
      function renderPostsByTag(postsArr, tag){
        const filteredPosts = postsArr.filter(post => post.tags.includes(tag));
        searchPostsState = filteredPosts
        renderByFilter(filteredPosts)
      }
    })

    function Challenge(){
      return JSON.parse(localStorage.getItem('challenge'))
    }
    function UrbitId(){
      return JSON.parse(localStorage.getItem('urbitId'))
    }
    function Rank(){
      return JSON.parse(localStorage.getItem('rank'))
    }
    function createDiv(idValue){
      const div = document.createElement('div');
      div.id = idValue
      return div
    }

  </script>
  <script>
    function closeErrorMessage(){
      const errElement = document.getElementById("errorMessage")
      errElement.style.display = "none";
      const errText = document.getElementById("errorText")
      errElement.removeChild(errText)
    }

    function addInput() {
      let container = document.getElementById('tagsInputContainer');
      container.style.display = "flex"
      container.style.gap = "5px"
      container.style.flexWrap = "wrap"
      let newInput = document.createElement('input');
      newInput.type = "text"
      newInput.className = "tagsInput"
      newInput.placeholder = "#tag"
      container.appendChild(newInput);
      newInput.focus();
    }
  </script>
</body>
</html>